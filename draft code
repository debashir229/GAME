#include <iostream>
#include <Windows.h>
#include <vector>
#include <conio.h>
using namespace std;



// ================= Data =================
const int HIGH = 5;
const int WIDTH = 12;
char Display[HIGH][WIDTH];
int fps = 60;
int latency = 1000 / 60;
// ========================================


class Point
{
public:
    int x;
    int y;
    char icon;
    Point() : x{ -1 }, y{ -1 }, icon{ '.' } {}
    Point(int X, int Y, const char Icon) : x{ X }, y{ Y }, icon{ Icon } {}
};




// ====== Класс всех сущностей ======
class Entity : public Point
{
public:
    Point coord;
    Entity() : coord{ -1 , -1 , '.' } {}
    Entity(Point exp) : coord{ exp.x, exp.y, exp.icon } {}


    Point getCoord()
    {
        return coord;
    }
    void setCoord(Point exp)
    {
        coord = exp;
    }


    virtual void push_pull() {};
    virtual int collision_handler() { return -1; };
};





// ====== Класс игровых сущностей ======
class SuperObject : public Entity
{
private:
    float health;
    float armor;
    unsigned level;
    int speed;
    Point my_coord = getCoord();
public:
    SuperObject() : health{ 0.0 }, armor{ 0.0 }, level{ 1 }, speed{ latency } {}
    SuperObject(float hp, float Armor, unsigned short lvl, int Speed, int X, int Y, char Icon) : health{ hp }, armor{ Armor }, level{ lvl }, speed{ Speed * latency } {}
    explicit SuperObject(Point exp) : health{ 0.0 }, armor{ 0.0 }, level{ 1 }, speed{ latency } {}

    // Движение объекта с учетом границ игрового поля
    bool up()
    {
        if(Display[my_coord.y - 1][my_coord.x] == '.')
            my_coord.y -= 1;
        return (my_coord.y >= 0);
    }
    bool down()
    {
        if (Display[coord.y + 1][coord.x] == '.')
            coord.y += 1;
        return (coord.y < HIGH);
    }
    bool right()
    {
        if (Display[coord.y][coord.x + 1] == '.')
            coord.x += 1;
        return (coord.x < WIDTH);
    }
    bool left()
    {
        if (Display[coord.y][coord.x - 1] == '.')
            coord.x -= 1;
        return (coord.x >= 0);
    }
    void back()
    {
        if (coord.x < 1)
            coord.x = WIDTH - 1;
        if (coord.x > WIDTH - 1)
            coord.x = 0;
        if (coord.y < 1)
            coord.y = HIGH - 1;
        if (coord.y > HIGH - 1)
            coord.y = 0;
    }
    //


    // Базовая механика толкай - тяни

    void push_pull()
    {
        char temp = ' ';
        if (my_coord.x < HIGH - 1)
            char temp = Display[my_coord.y][my_coord.x + 1];
        Display[my_coord.y][my_coord.x + 1] = ' ';

        
    }
    //virtual short collision_handler(Entity* ) = 0;
    //void hit()
    //{
    //    _
    //}
   


    
};
class Box : public Point
{
    Point coord;
};
// ====== Инвентарь ======
class Inventory
{
    vector <char> inv{};
    Inventory() : inv{ } {}
    Inventory(vector <char> I) : inv{ I } {}
    void del()
    {
        /* NULL */
    }
};
vector <Point> pointArr{};
vector <SuperObject> people{};





int main()
{

#pragma region Setting
    srand(time(NULL));
    Sleep(1000);
    system("cls");
    int _getch();
#pragma endregion

    Point smth{ 2, 4, '|' };
    Point hero{ 2, 2, 'i' };
    Entity door{ smth };
    SuperObject me{ hero };
    pointArr.push_back(smth);
    pointArr.push_back(me);
    people.push_back(me);
    int f_main = true;
    while (f_main == true)
    {
        for (int i = 0; i < HIGH; i++)
            for (int j = 0; j < WIDTH; j++)
                Display[i][j] = '.';


        for (int i = 0; i < pointArr.size(); i++)
            Display[pointArr[i].y][pointArr[i].x] = pointArr[i].icon;


        for (int i = 0; i < HIGH; i++)
        {
            for (int j = 0; j < WIDTH; j++)
                cout << Display[i][j];
            cout << endl;
        }
        for (int i = 0; i < people.size(); i++)
        {
            char WhatToDo = _getch();
            bool temp_flag = true;
            switch (WhatToDo)
            {
            case 'w':
                temp_flag = people[i].up();
                break;
            case 's':
                temp_flag = people[i].down();
                break;
            case 'a':
                temp_flag = people[i].left();
                break;
            case 'd':
                temp_flag = people[i].right();
                break;
            case 'e':
                people[i].push_pull();
                break;
            }
            if (temp_flag == false)
                people[i].back();
        }
        Sleep(latency);
        system("cls");
    }

}


}
